1. Content Delivery Network
    A (CDN) refers to a distributed group of servers which work together to provide fast delivery of Internet content.
    Benefits of CDN :
        a. Improving website load times / minimize latency
        b. Reducing bandwidth costs
        c. Increasing content availability
        d. Improving website security

    In order to improve speed and connectivity, a CDN will be place at the exchange
    points between different networks.

    eg - Akamai, Open connect (Netflix)

    A website is hosted on AWS in USA somewhere. For the people of USA it will take only 10-20 milli seconds for
    fetching data. But for the people of India it will take 3-4 secs. There are strategies for minimize this request
    latency for users that are far away. You always have to keep these strategies in mind when designing or building
    systems on the global scale.

    Static data we store at CDN. Every CDN has it's own local cache which should all be in sync.
    There are two types of CDN's
        1. Pull based CDN - CDN will pull data from server, more popular, maintanence is low
        2. Push based CDN - Server will send data to CDN

    We use cdn's for reduce latency for static files, but not most api requests. We should not use cdn's if our users
    are from a specific target location. CDN will also not be a good idea if our most of assets are dynamic and sensitive.

2. Distributed Cache    =>  Redis

2. Time Series Database     =>      InFluxDB, TimeScaleDB

3. Pub/Sub Model
    The Publish/Subscribe pattern, also known as pub/sub, is an architectural design pattern
    that provides a framework for exchanging messages between publishers and subscribers. This
    pattern involves the publisher and the subscriber relying on a message broker that relays
    messages from the publisher to the subscribers. The host (publisher) publishes messages (events)
    to a channel that subscribers can then sign up to.


4. Event Driven Architecture
    Two microservices communicate with each other based on event bus.
    An e-commerce application that uses this approach would work as follows:
        a. The Order Service creates an Order in a pending state and publishes an OrderCreated event.
        b. The Payment Service receives the event and attempts to reserve credit for that Order.
            It then publishes either a Credit Reserved event or a CreditLimitExceeded event.
        c. The Order Service receives the event from the Customer Service and changes the state of
            the order to either approved or cancelled


5. Service Discovery    =>  Eureka

    A microservices-based application typically runs in virtualized or containerized environments. The number of instances
    of a service and its locations changes dynamically. We need to know where these instances are and their names to allow
    requests to arrive at the target microservice. This is where tactics such as Service Discovery come into play.

    The Service Discovery mechanism helps us know where each instance is located. In this way, a Service Discovery
    component acts as a registry in which the addresses of all instances are tracked.

6. Database Sharding
    Example of horizontal scaling
        User table - Storing all the users
        After Sharding -
            Stores  A-I in user1 table
                    J-S in user2 table
                    T-Z in user3 table


7. Load Balancing   =>  Ribbon
    Load balancing refers to the process of distributing a set of tasks over a set of resources,
    with the aim of making their overall processing more efficient.
    Algorithms :
        a. Round Robin
        b. Hash
        c. Consistent Hash
        d. Least Connection

    Benefits:
        a. Reduce Downtime
        b. Increase Performance
        c. Scalability
        d. Flexibility

8. nginx - https://medium.com/devopscurry/what-is-nginx-understanding-the-basics-of-nginx-in-2021-f8ee0f3d3d54

8. Consistent Hashing
    https://medium.com/@sandeep4.verma/consistent-hashing-8eea3fb4a598

    Hashing is a technique of mapping one piece of data of some arbitrary size into another piece of data of fixed size,
    typically an integer, known as hash or hash code.

9. Scaling
    Vertical => Buying a bigger system
    Horizontal => Increasing number of instances

12. Apache Kafka

13. Zuul    =>  API Gateway

    An API gateway is a component that sits between clients and services and provides centralized handling of API
    communication between them. It also delivers security, policy enforcement, monitoring and visibility across
    on-premises, multi-cloud, and hybrid environments.

    An API gateway accepts API requests from a client, processes them based on defined policies, directs them to the
    appropriate services, and combines the responses for a simplified user experience.

    Separate Out
        Authentication
        Authorization
        SSL Certification
        Cache
        Static Content
        Also decides where to route a request based on url(ms1 or ms2)

14. Executor Service
     Java provides its own multi-threading framework called the Java Executor Framework.
            1. SingleThreadExecutor =>  LinkedBlockingQueue
            2. FixedThreadPool(n)   =>  LinkedBlockingQueue
            3. CachedThreadPool     =>  SynchronousQueue
            4. ScheduledExecutor    =>  DelayQueue

15. Ideal Thread Pool Size
    CPU Oriented - no. of threads = no. of cores
    I/O Oriented - no. of threads = no. of cores * (1 + waitTime/CPUTime)

17. Resilience4J    =>  Fault Tolerance
    a. Auto Retry
    b. Circuit Breaker
    c. Bulkhead - if we want to limit the number of concurrent requests, we can use Bulkhead
    d. Timer - Time Limiting is the process of setting a time limit for a Microservice to respond
    e. Rate Limiter

    https://javatechonline.com/how-to-implement-fault-tolerance-in-microservices-using-resilience4j/#What_is_Bulkhead

18. Map Struct  =>  Java Mapper class

19. SOLID
    S   =>  Single Responsibility   =>  Single Responsibility Class
    O   =>  Open Close Principle    =>  Open for extension & close for modification
    L   =>  Liskov Substitution     =>  A = parent & B = child, then we should be able to replace objects of A with objects of B
    I   =>  Interface Segregation   =>  Single Responsibility Interface
    D   =>  Dependency Inversion    =>  High-level modules should not depend upon low-level modules. They should depend on abstractions

20. CAP Theorem

    A partition is a communications break within a distributed system — a lost or temporarily delayed connection between
    two nodes. Partition tolerance means that the cluster must continue to work despite any number of communication
    breakdowns between nodes in the system.

21. Indexing - https://chartio.com/learn/databases/how-does-indexing-work/

22. Pagination is the task of dividing the potential result into pages and retrieving the
    required pages, one by one on demand. Using OFFSET and LIMIT is the easy way to write
    pagination into database queries

        client requests parameters with a specific limit (the number of results) and
        offset (the number of records that need to be skipped)

23. CI/CD Pipeline - https://dzone.com/articles/learn-how-to-setup-a-cicd-pipeline-from-scratch

24. What happens if hashCode & equals is not overriden?

    *** You must override hashCode() in every class that overrides equals().

    If you don't override hashcode() then the default implementation in Object class will be
    used by collections. This implementation gives different values for different objects, even
    if they are equal according to the equals() method.

    Some collections, like HashSet, HashMap or HashTable use the hash code to store its data and
    to retrieve it. If you don't implement hashcode() and equals() in a consistent manner, then
    they will not function properly.

    https://www.techiedelight.com/why-override-equals-and-hashcode-methods-java/


25. Marker Interface
    It is an empty interface (no field or methods). Examples of marker interface are Serializable,
    Cloneable and Remote interface.

    public interface Serializable {}

26. Concurrency Model
    1. Parallel Workers
    2. Assembly Line
    3. Functional Parallelism   =>  Fork/Join Pool

27. Bean Scope => The scope of a bean defines the life cycle and visibility of that bean
    1. Singleton - single instance per Spring IoC container
    2. Prototype - single bean definition to have any number of object instances
    3. Request - a bean definition to an HTTP request
    4. Session - a bean definition to an HTTP session
    5. Global - a bean definition to a global HTTP session

28. Time Complexity Depends on
    1. Single vs multi processor
    2. i/o operations
    3. 32 bit vs 64 bit
    4. input => rate of growth of time a/c to input

29. @SpringBootApplication Annotation
    Many Spring Boot developers like their apps to use auto-configuration, component scan and be able to define extra
    configuration on their "application class". A single @SpringBootApplication annotation can be used to enable those
    three features, that is:

        @EnableAutoConfiguration: enable Spring Boot’s auto-configuration mechanism
        @ComponentScan: enable component scan on the package where the application is located
        @Configuration: allow to register extra beans in the context or import additional configuration classes

30. Spring IoC (Inversion of Control)
    0. Inversion of Control is a principle in software engineering which transfers the control of objects to a container
    1. Spring IoC Container is the core of Spring Framework. It creates the objects, configures and assembles their
       dependencies, manages their entire life cycle.
    2. Spring IoC is achieved through Dependency Injection.
    3. Aspect-Oriented Programing is one way to implement Inversion of Control.
    4. Bean Factory and Application Context

31. Spring Dependency Injection
    0. Dependency Injection is a fundamental aspect of the Spring framework, through which the Spring container “injects”
       objects into other objects or “dependencies”.
    1. Dependency injection types are Constructor Injection and Setter Injection
    2. Dependency Injection helps in the creation of loosely-coupled applications.
    3. Dependency Injection is one of the subtypes of the IOC principle.
    4. In case of any changes in business requirements, no code change is required.

32. Spring Bean Life Cycle
    Bean life cycle is managed by the spring container. When we run the program then, first of all, the spring container
    gets started. After that, the container creates the instance of a bean as per the request, and then dependencies are
    injected. And finally, the bean is destroyed when the spring container is closed. Therefore, if we want to execute
    some code on the bean instantiation and just after closing the spring container, then we can write that code inside
    the custom init() method and the destroy() method.

35. Forward Proxy
    A forward proxy is an application that sits in front of client's device and placed b/w device & internet. Blocking
     unwanted urls while using office laptops


36. Reverse proxy / API Gateway
    In computer networks, a reverse proxy is an application that sits in front of back-end applications and forwards
    client requests to those applications. Reverse proxies help increase scalability, performance, resilience and security.


37. Performance vs scalability
    If you have a performance problem, your system is slow for a single user.
    If you have a scalability problem, your system is fast for a single user but slow under heavy load.


38. Latency vs throughput
    Latency is the time to perform single task or to produce some result.
    Throughput is the number of such actions or results per unit of time.
    Generally, you should aim for maximal throughput with acceptable latency.


39. HTTP    <<<<====>>>>    FTP
    1.	HyperText Transfer Protocol.    <<<<====>>>>    File Transfer Protocol
    2.	It is the set of rules that how web pages are transferred on different computers over the internet.    <<<<====>>>>    It is the set of rules that permit the downloading and uploading the files on the computer over the internet.
    3.	It only supports the data connection.    <<<<====>>>>    It supports both data connection and control connection
    4.	It uses Transmission Control Protocol and runs on TCP port 80.	It uses Transmission Control Protocol and runs on TCP port 20 and TCP port 21.
    5.	It does not require authentication.    <<<<====>>>>    It requires authentication.
    6.	It is efficient in transferring small files.    <<<<====>>>>    It is efficient in transferring large files.
    7. 	The files transferred to the computer over the internet are not saved to the memory.    <<<<====>>>>    The files transferred to the computer over the internet are saved to the memory.
    8.	It is a stateless protocol.    <<<<====>>>>    It is not a stateless protocol and it maintains states.
    9.	HTTP is faster.    <<<<====>>>>    FTP is slower as compared to HTTP.


40. TCP    <<<<====>>>>    UDP
    1. TCP is a connection-oriented protocol.    <<<<====>>>>    UDP is the Datagram-oriented protocol.
    2. TCP provides extensive error-checking mechanisms.    <<<<====>>>>    UDP has only the basic error-checking mechanism using checksums.
    3. An acknowledgment segment is present.    <<<<====>>>>    No acknowledgment segment.
    4. Sequencing of data is a feature of TCP.    <<<<====>>>>    There is no sequencing of data in UDP.
    5. TCP is comparatively slower than UDP.    <<<<====>>>>    UDP is faster, simpler, and more efficient than TCP.
    6. TCP is heavy-weight.    <<<<====>>>>    UDP is lightweight.
    7. Uses handshakes such as SYN, ACK, SYN-ACK.    <<<<====>>>>    It’s a connectionless protocol i.e. No handshake
    8. TCP doesn’t support Broadcasting.    <<<<====>>>>    UDP supports Broadcasting.


41. Secure Sockets Layer (SSL)
    1. The web browser sends the server a copy of its SSL certificate.
    2. The server checks to see whether or not it trusts the SSL certificate. If so, it sends a message to the web browser.
    3. The web browser sends back a digitally signed acknowledgement to start an SSL encrypted session.


42. GIT Merge vs Rebase
    1. Total 3 commits, A-B-C
    2. Then developer Dan created commit D, and developer E created commit E:
        A-B-C-D
             -E

    3. Obviously, this conflict should be resolved somehow. For this, there are 2 ways:
        MERGE: A-B-C-D
                    -E-M

    4. Both commits D and E are still here, but we create merge commit M that inherits changes from both D and E.
    However, this creates diamond shape, which many people find very confusing.

    REBASE: A-B-C-D-R
    5. We create commit R, which actual file content is identical to that of merge commit M above. But, we get rid of
    commit E, like it never existed. Because of this obliteration, E should be local
    to developer E and should have never been pushed to any other repository. Advantage of rebase is that diamond
    shape is avoided, and history stays nice straight line - most developers love that!

43. Asymptotic Notation
    Asymptotic notation is a way to describe the running time or space complexity of an algorithm based on the input size.
    The three most commonly used notations are Big O, Omega, and Theta.

    Big O notation (O): This notation provides an upper bound on the growth rate of an algorithm’s running time or space
    usage. It represents the worst-case scenario, i.e., the maximum amount of time or space an algorithm may need to
    solve a problem. For example, if an algorithm’s running time is O(n), then it means that the running time of the
    algorithm increases linearly with the input size n or less.

    Omega notation (Ω): This notation provides a lower bound on the growth rate of an algorithm’s running time or space
    usage. It represents the best-case scenario, i.e., the minimum amount of time or space an algorithm may need to
    solve a problem. For example, if an algorithm’s running time is Ω(n), then it means that the running time of the
    algorithm increases linearly with the input size n or more.

    Theta notation (Θ): This notation provides both an upper and lower bound on the growth rate of an algorithm’s
    running time or space usage. It represents the average-case scenario, i.e., the amount of time or space an algorithm
    typically needs to solve a problem. For example, if an algorithm’s running time is Θ(n), then it means that the
    running time of the algorithm increases linearly with the input size n

44. Jar (Java Archieve) - A collection of .class files
    War (Web Archieve) - An entire web appication in zipped form. (.class, .xml, .html, .css, .properties etc)
    Ear (Enterprize Archive) - An Enterprize application in zipped form.

45. Web Application - 1. We can use only web releated technologies.
                        2. Web server needs to run web applications.
    Enterprize Application - 1. we can use anything from Java J2EE like EJB, JMS etc.
                            2. Application server needs to run enterprize application.


48. Postgres reads were generally slower than MySQL, but it was capable of writing large amounts of data more efficiently,
    and it handled concurrency better.

    Postgres is an object-relational database, while MySQL is a purely relational database. This means that Postgres
    includes features like table inheritance and function overloading, which can be important to certain applications.

    PostgreSQL supports all MySQL data types along with geometric, enumerated, network address, arrays, ranges, XML,
    hstore, and composite.

 47. HashMap

    Initial array size size is 16 buckets, load factor is 0.75. Meaning when it gets (watch that word) 12, it resizes to 32 buckets

    Using a HashMap with an initial capacity can be beneficial in certain scenarios where you have a good estimate of
    the expected number of elements.

     If entries in a single bucket reach a threshold (TREEIFY_THRESHOLD, default value 8) then Map converts the bucket’s
     internal structure from the linked list to a RedBlackTree. All Entry instances are converted to TreeNode instances.
     To improve retrieval performance, the HashMap converts the linked list into a balanced tree (Red-Black tree) during
     rehashing, ensuring more efficient retrieval (O(log n)) instead of linear search (O(n)). Note that when nodes in a
     bucket reduce less than UNTREEIFY_THRESHOLD the Tree again converts to LinkedList.

48. In Java, a static class is actually an inner class that is marked with the static keyword. This means that it can
 be accessed without instantiating the outer class.

49. In Java, the serialVersionUID is a unique identifier for each class that implements the Serializable interface. It
is used during the deserialization process to ensure that a loaded class corresponds exactly to a serialized object. If
a class does not explicitly declare a serialVersionUID, the Java serialization runtime will calculate one based on various
aspects of the class, which can lead to unexpected InvalidClassException if the class structure changes.

    Key Points
    Version Control: The serialVersionUID helps in version control of the serialized data. By assigning a unique ID to
    each version of a class, you can maintain compatibility between different versions of a class.

    Compatibility: It ensures that an object serialized with one version of the class can be deserialized with another
    version, as long as the serialVersionUID remains unchanged. If it is different, it indicates that the class structure
    has changed, and the runtime will throw an InvalidClassException.

    Explicit Declaration: It is a good practice to explicitly declare a serialVersionUID to avoid the compiler generating
    one automatically, which can be inconsistent across different compiler implementations or versions.

50. How to Optimize 10,000 If-Else Statements in a Project?

    1. Replace if-else chains with HashMap

        public class Main {
            public static void main(String[] args) {
                Map<String, Runnable> actions = new HashMap<>();
                actions.put("action1", () -> System.out.println("Action 1 executed"));
                actions.put("action2", () -> System.out.println("Action 2 executed"));
                actions.put("action3", () -> System.out.println("Action 3 executed"));

                String actionKey = "action1";
                actions.get(actionKey).run();
            }
        }

    2. Enums with execute / Switch

        public class Main {
            enum Action {
                ACTION1 {
                    @Override
                    void execute() {
                        System.out.println("Action 1 executed");
                    }
                },
                ACTION2 {
                    @Override
                    void execute() {
                        System.out.println("Action 2 executed");
                    }
                }
                abstract void execute();
            }

            public static void main(String[] args) {
                Action action = Action.ACTION1;
                action.execute();
            }
        }

    3. Strategy Pattern - Create seperate class for each condition

51. Spring Features
    1. AutoConfiguration
    2. Spring Profiles
    3. Dependency Injection
    4. Sping Boot Actuator
    5. Spring cloud
    6. Spring security
    7. IOC Container